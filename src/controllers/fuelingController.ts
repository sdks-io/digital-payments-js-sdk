/**
 * Shell SmartPay APILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

import { ApiResponse, RequestOptions } from '../core';
import {
  MppAccesTokenResponse,
  mppAccesTokenResponseSchema,
} from '../models/mppAccesTokenResponse';
import {
  PrepareFuelingRequest,
  prepareFuelingRequestSchema,
} from '../models/prepareFuelingRequest';
import {
  PrepareFuelingResponse,
  prepareFuelingResponseSchema,
} from '../models/prepareFuelingResponse';
import { string } from '../schema';
import { BaseController } from './baseController';
import { ApiError } from '@apimatic/core';
import { CancelFuelingErrorResponseError } from '../errors/cancelFuelingErrorResponseError';
import { MppAccesTokenErrorResponseError } from '../errors/mppAccesTokenErrorResponseError';

export class FuelingController extends BaseController {
  /**
   * The Digital Payments Service enables 3rd Parties to trigger the refuel process which, if successful,
   * will unlock a pump/nozzle ready for fuelling. Enables a 3rd party to request an access token to
   * start using fueling.
   * APIs
   *
   * @param grantType     In OAuth 2.0, the term grant type refers to the way an application gets an access
   *                                token. OAuth 2.0 defines several grant types, including the authorization code flow.
   * @param clientId      After registering your app, you will receive a client ID and a client secret. The
   *                                client ID is considered public information, and is used to build login URLs, or
   *                                included in Javascript source code on a page.
   * @param clientSecret  After registering your app, you will receive a client ID and a client secret. The
   *                                client ID is considered public information, and is used to build login URLs, or
   *                                included in Javascript source code on a page. The client secret must be kept
   *                                confidential.
   * @return Response from the API call
   */
  async mppToken(
    grantType: string,
    clientId: string,
    clientSecret: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<MppAccesTokenResponse>> {
    const req = this.createRequest('POST', '/Fueling/v1/oauth/token');
    const mapped = req.prepareArgs({
      grantType: [grantType, string()],
      clientId: [clientId, string()],
      clientSecret: [clientSecret, string()],
    });
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.form({
      grant_type: mapped.grantType,
      client_id: mapped.clientId,
      client_secret: mapped.clientSecret,
    });
    req.throwOn(
      401,
      MppAccesTokenErrorResponseError,
      'Unauthorized. The request has not been applied because it lacks valid authentication credentials for the target resource.'
    );
    req.authenticate([{ oAuthTokenPost: true }]);
    return req.callAsJson(mppAccesTokenResponseSchema, requestOptions);
  }

  /**
   * Enables a 3rd party to request to unlock a pump so that they may fill up to a pre-authorised limit.
   * The fuel types that are unlocked may also be determined by permitted fuels stored against the
   * user/entity profile
   *
   * @param siteCountry  Country ISO code
   * @param currency     Currency ISO code
   * @param body
   * @return Response from the API call
   */
  async mppPrepareFueling(
    siteCountry: string,
    currency: string,
    body: PrepareFuelingRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<PrepareFuelingResponse>> {
    const req = this.createRequest('POST', '/Fueling/v1/fueling');
    const mapped = req.prepareArgs({
      siteCountry: [siteCountry, string()],
      currency: [currency, string()],
      body: [body, prepareFuelingRequestSchema],
    });
    req.header('Content-Type', 'application/json');
    req.query('siteCountry', mapped.siteCountry);
    req.query('currency', mapped.currency);
    req.json(mapped.body);
    req.throwOn(
      400,
      ApiError,
      'Error Occurred. Request did not include bearer token or token provided and is invalid.'
    );
    req.throwOn(401, ApiError, 'Unauthorized');
    req.throwOn(
      403,
      ApiError,
      'Forbidden. Requestor is not permitted to call the API'
    );
    req.throwOn(
      404,
      ApiError,
      'Not Found. Request received by the server but requested URL not found'
    );
    req.authenticate([{ oAuthTokenPost: true, mppToken: true }]);
    return req.callAsJson(prepareFuelingResponseSchema, requestOptions);
  }

  /**
   * Enables a partner user to cancel pump reservation from the App
   *
   * @param mppTransactionId The ID of the transaction thatâ€™s being cancelled
   * @return Response from the API call
   */
  async mppCancelFueling(
    mppTransactionId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      mppTransactionId: [mppTransactionId, string()],
    });
    req.appendTemplatePath`/Fueling/v1/fueling/${mapped.mppTransactionId}`;
    req.throwOn(
      400,
      CancelFuelingErrorResponseError,
      'Error Occurred. The server cannot or will not process the request due to an apparent client error (e.g., malformed request syntax, invalid request message). Please see below for information regarding structure of Response Body vs. all possible errors that could be returned.'
    );
    req.throwOn(
      401,
      CancelFuelingErrorResponseError,
      'Unauthorized. Request did not include bearer token or token provided and is invalid.'
    );
    req.throwOn(
      403,
      ApiError,
      'Forbidden. Requestor is not permitted to call the API.'
    );
    req.throwOn(
      404,
      ApiError,
      'Not Found. Request received by the server but requested URL not found'
    );
    req.authenticate([{ oAuthTokenPost: true, mppToken: true }]);
    return req.call(requestOptions);
  }
}
